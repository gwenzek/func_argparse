import argparse
import collections
import enum
import functools
import inspect
import sys
import typing
from argparse import ArgumentParser
from types import FunctionType, ModuleType
from typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union

AnyCallable = Callable[..., Any]
_GenericAlias = type(Union[int, str])
Parser = Union[type, Callable[[str], Any]]
R = typing.TypeVar("R", covariant=True)

COMMAND_KEY = "__command"


def main(*fns: AnyCallable, description: str = None, module: ModuleType = None) -> Any:
    """Parses command line arguments and call the chosen function with them.

    Arguments:
        - fns: list of function that can be launched from command line.
            Each function must have type hints, so that we know how to parse them.
        - description: help message to show on command line
        - module: will use the module to search functions and chose the description.
    """
    return make_main(*fns, module=module, description=description)(sys.argv[1:])


def single_main(fn: Callable[..., R]) -> R:
    """Parses command line arguments and call the given function with them."""
    return make_single_main(fn)(sys.argv[1:])


def make_single_main(fn: Callable[..., R]) -> Callable[[Sequence[str]], R]:
    """Parses command line arguments and call the given function with them."""
    parser = func_argparser(fn)
    return _make_main(parser)


def make_main(
    *fns: AnyCallable, module: ModuleType = None, description: str = None
) -> Callable[[Sequence[str]], Any]:
    """Creates a main method for the given module / list of functions.

    The returned method expects a list of command line arguments.
    """
    if module is None:
        module = sys.modules["__main__"]
    if description is None:
        description = module.__doc__
    if not fns:
        fns = tuple(resolve_public_fns(module))
    parser = multi_argparser(*fns, description=description)

    return _make_main(parser)


def parse_and_call(parser: ArgumentParser, args: Sequence[str] = None) -> Any:
    parsed_args = vars(parser.parse_args(args))
    if not parsed_args:
        # Show help for multi argparser receiving no arguments.
        parser.print_help()
        parser.exit()
    assert COMMAND_KEY in parsed_args, (
        f"Parser {parser} wasn't generated by func_argparser."
        f" It needs a '{COMMAND_KEY}' key."
    )
    command = parsed_args.pop(COMMAND_KEY)
    return command(**parsed_args)


def _make_main(parser: ArgumentParser) -> Callable[[Sequence[str]], R]:
    return functools.partial(parse_and_call, parser)


def resolve_public_fns(module: ModuleType = None) -> List[FunctionType]:
    if module is None:
        module = sys.modules["__main__"]

    # We only keep FunctionType because argspec works with those.
    # This will exclude builtins and C-funtions.
    fns = list(
        fn
        for n, fn in vars(module).items()
        if not n.startswith("_") and isinstance(fn, FunctionType)
    )
    return [fn for fn in fns if fn.__module__ == module.__name__]


def get_documentation(fn: AnyCallable) -> List[str]:
    fn_doc = fn.__doc__.split("\n") if fn.__doc__ else []
    init_doc: List[str] = []
    if isinstance(fn, type):
        # Sometimes init is actually the parent object init and the docstring may
        # be weird or too generic. Yet we don't want to force the user to override
        # parent init method just so they can change the docstring.
        # In this case we probably just want to use the class docstring first.
        init_docstr = fn.__init__.__doc__  # type: ignore[misc]
        if init_docstr:
            # tuple.__init__.__doc__ isn't helpful so we ignore it.
            if fn.__init__ != tuple.__init__:  # type: ignore[misc]
                init_doc = init_docstr.split("\n")

    return [l.strip() for l in init_doc + fn_doc if l.strip()]


def get_fn_description(fn: AnyCallable) -> Optional[str]:
    """Returns the first line of a function doc string."""
    doc = get_documentation(fn)
    return doc[0] if doc else None


def _get_arguments_description(
    fn: AnyCallable, signature: inspect.FullArgSpec, defaults: Dict[str, Any]
) -> Dict[str, str]:
    """Returns a description for each argument."""
    lines = get_documentation(fn)
    if not lines:
        return {}
    descriptions = {}
    lines = list(filter(None, (l.strip("-* ") for l in lines)))
    for a in signature.args:
        # TODO: some arguments may have more than one line of documentation.
        doc = next((l[len(a) :].strip(" :") for l in lines if l.startswith(a)), None)
        default = defaults.get(a)

        # Don't show values defaulting to None.
        default_doc = f"(default={default})" if default is not None else None

        # Only talk about the --no flag if the default is True
        if signature.annotations.get(a) == bool and default is True:
            default_doc = f"(default={default}, --no-{a} to disable)"

        descriptions[a] = " ".join(filter(None, (doc, default_doc)))

    return descriptions


def multi_argparser(
    *fns: AnyCallable, description: str = None, **parsers: ArgumentParser
) -> ArgumentParser:
    """Creates an ArgumentParser with one subparser for each given function.

    Args:
        - fns: functions
        - parsers: already created parser
        - description: description of the full parser

    Note:
        `multi_argparser(f)` <=> `multi_argparser(f=func_argparser(f))`
    """

    for fn in fns:
        assert fn.__name__ not in parsers, f"Name of {fn} is already used."
        parsers[fn.__name__] = func_argparser(fn)

    parser = ArgumentParser(description=description, add_help=True)
    subparsers = parser.add_subparsers()

    for name, p in parsers.items():
        # TODO: allow aliases
        aliases: List[str] = []
        _help = p.description
        subparsers._name_parser_map[name] = p
        choice_action = subparsers._ChoicesPseudoAction(name, aliases, _help)
        subparsers._choices_actions.append(choice_action)

    return parser


def _is_option_type(t: Any) -> bool:
    if not isinstance(t, _GenericAlias):
        return False
    return (
        t.__origin__ == Union
        and len(t.__args__) == 2
        and issubclass(t.__args__[1], type(None))
    )


def _get_list_contained_type(t: Any) -> Optional[Type[Any]]:
    if not isinstance(t, _GenericAlias):
        return None
    if t.__origin__ not in (list, collections.abc.Sequence):
        return None
    contained = t.__args__[0]
    assert isinstance(contained, type)
    return contained


def _parse_enum(enum: enum.EnumMeta, flags: List[str], value: str) -> enum.Enum:
    members = tuple(enum.__members__)
    # enum members might be case sensitive.
    if value in members:
        return enum[value]
    if value.upper() in members:
        return enum[value.upper()]

    # Mimick argparse error message for choices.
    # See https://github.com/python/cpython/blob/3.7/Lib/argparse.py#L2420
    msg = f"invalid choice: '{value}' (choose from {', '.join(members)})"
    action = argparse.Action(flags, "")
    raise argparse.ArgumentError(action, msg)


def _parse_union(
    parsers: List[Parser], union: type, flags: List[str], value: str
) -> Any:
    for p in parsers:
        try:
            return p(value)
        except Exception:
            continue
    pretty = str(union)[len("typing.") :]
    msg = f"invalid {pretty} value: '{value}'"
    action = argparse.Action(flags, "")
    raise argparse.ArgumentError(action, msg)


def _get_parser(t: Parser, flags: List[str]) -> Parser:
    # TODO: this abstraction doesn't hold off, we often need to modify the
    # underlying 'action' to be consistent with the parser.
    # this function should receive a reasonable action and only change the parts
    # needed for this type.
    if isinstance(t, enum.EnumMeta):
        return functools.partial(_parse_enum, t, flags)
    if _is_option_type(t):
        assert isinstance(t, _GenericAlias)
        return _get_parser(t.__args__[0], flags)
    if isinstance(t, _GenericAlias) and t.__origin__ is Union:
        parsers = [
            _get_parser(st, flags)
            for st in t.__args__
            if not issubclass(st, type(None))
        ]
        return functools.partial(_parse_union, parsers, t, flags)

    if isinstance(t, type):
        ct = _get_list_contained_type(t)
        if ct is not None:
            return _get_parser(ct, flags)

    return t


def func_argparser(
    fn: AnyCallable, parser: Optional[ArgumentParser] = None
) -> ArgumentParser:
    """Creates an ArgumentParser for the given function."""
    if not parser:
        parser = ArgumentParser(description=get_fn_description(fn))
    parser.set_defaults(**{COMMAND_KEY: fn})

    spec = inspect.getfullargspec(fn)
    args = spec.args
    if isinstance(fn, type):
        # Ignore `self` from `__init__` method.
        args = args[1:]
    for a in args:
        assert a in spec.annotations, f"Need a type annotation for argument {a} of {fn}"

    if spec.defaults:
        defaults = dict(zip(reversed(args), reversed(spec.defaults)))
    else:
        defaults = {}
    args_desc = _get_arguments_description(fn, spec, defaults)

    # One letter arguments are given the short flags.
    prefixes: Set[str] = set(a for a in args if len(a) == 1)
    # -h is always for help.
    prefixes.add("h")
    for a, t in spec.annotations.items():
        if a == "return":
            continue
        doc = args_desc.get(a)
        flags = [f"--{a}"]
        if len(a) == 1 or a[0] not in prefixes:
            flags.insert(0, f"-{a[0]}")
            prefixes.add(a[0])

        if t is bool:
            d = defaults.get(a, False)
            parser.add_argument(*flags, default=d, action="store_true", help=doc)
            # The --no flags are hidden
            parser.add_argument(
                f"--no-{a}", dest=a, action="store_false", help=argparse.SUPPRESS
            )
            continue

        if _is_option_type(t):
            if a not in defaults:
                defaults[a] = None

        action = "store"
        t_contained = _get_list_contained_type(t)
        if t_contained is not None:
            action = "append"
            t = t_contained

        parser.add_argument(
            *flags,
            type=_get_parser(t, flags),
            action=action,
            default=defaults.get(a),
            required=a not in defaults,
            help=doc,
        )
    return parser


def override(
    argparser: ArgumentParser,
    name: str,
    short_name: str = None,
    # action: str = None,
    # nargs: str = None,
    # aliases: List[str] = None,
    default: Any = None,
    type: Callable[[str], Any] = None,
    choices: Sequence[str] = None,
    required: bool = None,
    help: str = None,
    metavar: str = None,
) -> None:
    # Notes:
    #   - nargs: TODO
    #   - actions: supporting this will require recreating the action
    #   - dest: Can't be changed afterward since it would result in some fn arg
    #     not being filled.
    #   - const: I don't think we want to change those, they are only use by
    #     boolean flags.
    #   - aliases: TODO replace shortname
    candidates = [a for a in argparser._actions if f"--{name}" in a.option_strings]
    assert candidates, f"Can't override behavior of unknown argument {name}."
    assert len(candidates) == 1, f"Found several arguments named {name}."
    action = candidates[0]
    if short_name is not None:
        action.option_strings = [short_name, f"--{name}"]
    if default is not None:
        action.default = default
        action.required = False
    if type is not None:
        action.type = type
    if choices is not None:
        # Useful if you don't want to rewrite code to use enum
        action.choices = choices
    if required is not None:
        assert (
            required or default is not None
        ), "Need a default value to make an argument optional."
        if required:
            action.required = required
            action.default = None
    if help is not None:
        action.help = None
    if metavar is not None:
        action.metavar = metavar
